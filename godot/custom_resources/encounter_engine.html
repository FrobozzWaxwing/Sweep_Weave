<!DOCTYPE html>
<html>
<head>
<!-- Storyworld Metadata -->
<meta charset="UTF-8">
<meta name="keywords" content="interactive fiction, interactive storytelling, text adventure, storyworld, game, SweepWeave">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- SweepWeave storyworld engine designed and developed by Sasha Fenn -->
<style>
/* General */
html {
    scroll-behavior: smooth;
}

button {
    cursor: pointer;
}

/* Collapsibles */

.collapsible {
    padding: 16px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 14px;
}

.collapsible-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.5s ease-out;
}

/* Menu */

.menu .row {
    border: none;
    display: block;
    text-align: left;
    width: 100%;
}

.menu .row:not(:last-child) {
    padding: 8px 16px 0px;
}

.menu .row:last-child {
    padding: 8px 16px;
}

.menu button {
    padding: 4px 6px;
    border: none;
    border-radius: 5px;
}

/* Popup Dialog Box */

#popupBackground {
	position: fixed;
	z-index: 98;
	top: 0; left: 0;
	width: 100vw; height: 100vh;
	align-items: center; justify-content: center;
	background: rgba(0, 0, 0, 0.25);
	display: flex;
	opacity: 0; visibility: hidden;
	transition: opacity 0.2s;
}

#popupBackground.show {
	opacity: 1; visibility: visible;
}

#popupDialog {
	position: relative;
	z-index: 99;
	min-width: 256px;
    max-width: 512px;
	align-items: center;
    justify-content: center;
    text-align: center;
	padding: 5px;
	background: #fff;
	border-radius: 10px;
}

#popupText {
	padding: 5px;
}

/* Dropdown Button */

.dropdown {
    display: inline-block;
}

.dropbtn {
    width: 100%;
    min-width: 80px;
}

.dropdown.show .dropbtn {
    border-bottom-right-radius: 0px;
    border-bottom-left-radius: 0px;
}

.dropdown-content {
    display: none;
    overflow: auto;
    border-bottom-right-radius: 5px;
    border-bottom-left-radius: 5px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1;
}

.dropdown.show .dropdown-content {
    display: block;
}

.dropdown-content button {
    border: none;
    display: block;
    padding: 4px 4px;
    border-radius: 0px;
    width: 100%;
}

.dropdown-content button:last-child {
    border-bottom-right-radius: 5px;
    border-bottom-left-radius: 5px;
}

/* Transcript */

#transcript {
    padding: 0px 16px;
}

/* Player Options */

#options_list {
    margin-left: 2px;
    margin-right: 2px;
}

.option {
    border: 1px solid black;
    border-width: 1px 1px 0px 1px;
    padding: 5px;
    transition: background-color 0.3s;
}

.option.first {
    border-top-right-radius: 5px;
    border-top-left-radius: 5px;
}

.option.last {
    border-width: 1px;
    border-bottom-right-radius: 5px;
    border-bottom-left-radius: 5px;
}

.option.single {
    border-width: 1px;
    border-radius: 5px;
}

.option.disabled {
}

.option.disabled:hover {
    cursor: auto;
}

.option .prefix {
    opacity: 0;
    transition: opacity 0.3s;
}

.option:hover .prefix {
    opacity: 1;
}

.option.disabled:hover .prefix  {
    opacity: 0;
}

/* Decorated Heading */

.decorated_heading {
    overflow: hidden;
    text-align: center;
}

.decorated_heading::before,
.decorated_heading::after {
    content: "";
    border-radius: 25px;
    display: inline-block;
    height: 2px;
    position: relative;
    vertical-align: middle;
    width: 50%;
}

.decorated_heading::before {
    right: 0.5em;
    margin-left: -50%;
}

.decorated_heading::after {
    left: 0.5em;
    margin-right: -50%;
}

/* Story Illustrations */

.illustration {
    width: auto;
    object-fit: contain;
    max-width: 100%;
    border-style: solid;
    border-width: 1px;
    display: block;
    margin: auto;
}

/* Visual Theme Options: */

/* Lilac Theme: */

body.lilac {
    background-color: LavenderBlush;
}

.lilac .collapsible {
    background-color: #453d5c;
    color: White;
}

.lilac .collapsible:hover {
    background-color: #675c8a;
}

.lilac .collapsible-content {
    background-color: Thistle;
}

.lilac .menu button {
    background-color: #453d5c;
    color: White;
}

.lilac .menu button:hover {
    background-color: #675c8a;
}

.lilac #popupDialog {
	background: White;
}

.lilac .dropdown-content button {
    background-color: LavenderBlush;
    color: Black;
}

.lilac .dropdown-content button.selected {
    background-color: Violet;
}

.lilac .dropdown-content button:hover {
    background-color: Violet;
}

.lilac .option:hover {
    background-color: PeachPuff;
}

.lilac .option.disabled {
    color: DimGray;
}

.lilac .option.disabled:hover {
    background-color: LavenderBlush;
}

.lilac .decorated_heading::before,
.lilac .decorated_heading::after {
    background-color: Black;
}

.lilac .illustration {
    border-color: Black
}

/* Nightshade Theme: */

body.nightshade {
    background-color: Black;
    color: White;
}

.nightshade .collapsible {
    background-color: #11268E;
    color: White;
}

.nightshade .collapsible:hover, .nightshade .menu button:hover, .nightshade .dropdown-content button.selected, .nightshade .dropdown-content button:hover {
    background-color: #5f1cb0;
}

.nightshade .collapsible-content {
    background-color: #4185D3;
    color: White;
}

.nightshade .menu button {
    background-color: #11268E;
    color: White;
}

.nightshade #popupDialog {
	background: GhostWhite;
    color: Black;
}

.nightshade .dropdown-content button {
    background-color: #050515;
}

.nightshade .option {
    background-color: #050515;
    border-color: GhostWhite;
}

.nightshade .option:hover {
    background-color: #5f1cb0;
}

.nightshade .option.disabled {
    color: Silver;
}

.nightshade .option.disabled:hover {
    background-color: Black;
}

.nightshade .decorated_heading::before,
.nightshade .decorated_heading::after {
    background-color: GhostWhite;
}

.nightshade .illustration {
    border-color: Black
}
</style>
<script type="text/javascript" src="storyworld_data.js"></script>
<script>

//--------------------------
//Section 1: Interface Functions
//--------------------------

//Popup Dialog

function showPopupDialog(msg) {
	if (msg != undefined) {
		document.getElementById("popupText").innerHTML = msg;
		document.getElementById("popupBackground").classList.add("show");
	} else { document.getElementById("popupBackground").classList.remove("show"); }
}

function hidePopupDialog(){
	document.getElementById("popupBackground").classList.remove("show");
}

var onPopupConfirmation = hidePopupDialog;
var popupArgument = "";
function confirmPopupDialog(){
	hidePopupDialog();
	onPopupConfirmation();
}

//Menu

var menuOpen = false;
function toggleMenu(){
    menuOpen = !menuOpen;
    if (menuOpen){
        openMenu();
    } else {
        closeMenu();
    }
}

function openMenu(){
    let menu = document.getElementById("main_menu");
    menu.style.maxHeight = menu.scrollHeight + "px";
}

function closeMenu(){
    let menu = document.getElementById("main_menu");
    menu.style.maxHeight = "0px";
}

function refreshMenu(){
    if (menuOpen){
        openMenu();
    } else {
        closeMenu();
    }
}

//About Popup

function displayAboutText(){
    onPopupConfirmation = hidePopupDialog;
    showPopupDialog(evaluateSWScript(storyworld_data.about_text));
}

//Transcript

var transcriptOpen = false;
function toggleTranscript(){
    transcriptOpen = !(transcriptOpen || "" == playthrough_transcript);
    if (transcriptOpen){
        openTranscript();
    } else {
        closeTranscript();
    }
}

function openTranscript(){
    let element = document.getElementById("transcript");
    let height = element.scrollHeight + 8;
    element.style.maxHeight = height + "px";
}


function closeTranscript(){
    let element = document.getElementById("transcript");
    element.style.maxHeight = "0px";
}

function refreshTranscript(){
    if (transcriptOpen){
        openTranscript();
    } else {
        closeTranscript();
    }
}

//Autoscroll

function focusStory(){
    let element = document.getElementById("story");
    element.scrollIntoView();
}

//Graphics Options
function setTheme(theme_name){
    var body = document.getElementsByTagName("BODY")[0];
    var lilac_button = document.getElementById("lilac_button");
    var nightshade_button = document.getElementById("nightshade_button");
    switch (theme_name){
        case "lilac":
            body.classList.remove("nightshade");
            body.classList.add("lilac");
            nightshade_button.classList.remove("selected");
            lilac_button.classList.add("selected");
            break;
        case "nightshade":
            body.classList.remove("lilac");
            body.classList.add("nightshade");
            lilac_button.classList.remove("selected");
            nightshade_button.classList.add("selected");
            break;
    }
}

function setFontSize(size){
    var element = document.getElementById("main_menu");
    element.style.fontSize = size + "px";
    element = document.getElementById("transcript");
    element.style.fontSize = size + "px";
    element = document.getElementsByTagName("BODY")[0];
    element.style.fontSize = size + "px";
    var options = ["14", "16", "18", "20"];
    for (option of options){
        element = document.getElementById("set_font_" + option);
        if (option == size){
            element.classList.add("selected");
        } else {
            element.classList.remove("selected");
        }
    }
}

function initiateGUI(){
    if (typeof storyworld_data !== 'undefined' && typeof storyworld_data.css_theme !== 'undefined' && typeof storyworld_data.font_size !== 'undefined'){
        setTheme(storyworld_data.css_theme);
        setFontSize(storyworld_data.font_size);
    } else {
        setTheme("lilac");
        setFontSize("16");
    }
}

//Dropdown Buttons

function toggleDropdown(id){
    var element = document.getElementById(id);
    element.classList.toggle("show");
    openMenu();//Used to refresh the height of the main menu.
}

//------------------
//Section 2: Classes
//Define classes for encounters, player options, (i.e. verbs,) character reactions, (i.e. more verbs,) and characters.
//------------------

//Define what an encounter consists of:
class Encounter {
    constructor(id, title, text_script, acceptability_script, desirability_script) {
        this.id = id;//a string that uniquely identifies this encounter, used for dictionary keys.
        this.title = title;//string
        this.text_script = text_script;
        this.acceptability_script = acceptability_script
        this.desirability_script = desirability_script
        this.options = [];//array
    }
}

//Define an option and its associated reactions:
class Player_Option {
    constructor(text_script, visibility_script, performability_script, reactions) {
        this.text_script = text_script;
        this.visibility_script = visibility_script;
        this.performability_script = performability_script;
        this.reactions = reactions;//array
    }
}

class Character_Reaction {
    constructor(text_script, desirability_script, consequence) {
        this.text_script = text_script;//Text to display to player if reaction is chosen.
        this.desirability_script = desirability_script;
        this.consequence = consequence;//An encounter that must happen next if reaction is chosen.
        this.after_effects = [];
    }
}

class Character {
    constructor(name, pronoun, bnumber_properties) {
        this.name = name;//The character's name.
        this.pronoun = pronoun;//They, she, he, etc.
        this.bnumber_properties = JSON.parse(JSON.stringify(bnumber_properties));//dictionary of personality traits.
    }
    get_bnumber_property(keyring){
        console.log("Fetching bounded number property " + JSON.stringify(keyring) + "from " + this.name);
        let first_loop = true;
        let property = keyring[0];
        let onion = null;
        for (const key of keyring){
            if (first_loop){
                first_loop = false;
                if (!Object.hasOwn(this.bnumber_properties, property)){
                    console.log("Property '" + property + "' not found.");
                    return 0;
                } else {
                    onion = this.bnumber_properties[property];
                }
            } else {
                if ("object" == typeof onion && Object.hasOwn(onion, key)){
                    onion = onion[key];
                } else if ("number" == typeof onion){
                    console.log("Result: " + onion.toString());
                    return onion;
                } else {
                    console.log("Invalid result. Returning 0.");
                    return 0;
                }
            }
        }
        if ("number" == typeof onion){
            //0-depth property.
            console.log("Result: " + onion.toString());
            return onion;
        }
    }
    set_bnumber_property(keyring, value){
        let property = keyring[0];
        let onion = null;
        let l = keyring.length;
        for (let index = 0; index < l; index++) {
            let key = keyring[index];
            if (0 == index){
                //First pass through loop.
                if (1 == l){
                    //This keyring refers to a 0-depth property.
                    this.bnumber_properties[property] = value;
                } else {
                    onion = this.bnumber_properties[property];
                }
            } else if (0 < index && index < (l - 1)){
                //Partway through loop.
                if ("object" == typeof onion && Object.hasOwn(onion, key)){
                    onion = onion[key];
                }
            } else{
                //Last pass through loop.
                if ("object" == typeof onion && Object.hasOwn(onion, key)){
                    onion[key] = value;
                }
            }
        }
    }
	saveData(){
		let output = {};
		output.name = this.name;
		output.pronoun = this.pronoun;
		output.bnumber_properties = JSON.parse(JSON.stringify(this.bnumber_properties));
		return output;
	}
    printCharRelationships(delimiter){
        let output = "";
        output += "<b>Name:</b> " + this.name + JSON.stringify(this.bnumber_properties);
        return output;
    }
}

class Spool {
    constructor(id, name, starts_active) {
        this.id = id;
        this.name = name;
        this.encounters = [];
        this.starts_active = starts_active;
        this.currently_active = starts_active;
    }
}

//-------------------
//Section 3: Database
//-------------------

//Here is the database of encounters.
var encounters = {};

//Here is the database of spools.
var spools = [];
var spool_directory = {};

//We need to keep track of the present encounter.
var current_page = null;
var next_page = "wild";//"wild" means a page is chosen semi-randomly; other values specify specific pages.
var turn = 0;
var text_buffer = "";//Used to store the text of a reaction so that it can be displayed at the start of the next encounter. Also used when encounters are broken into sections to store the text so far displayed.

//Here is the database of characters.
var characters = [];

//Here is the history book. Each entry includes an encounter, an option, and a reaction, but the option and reaction entries can equal -1, indicating that none have yet been selected. This database can be exported as a save file.

var slow_historybook = [
    //{"encounter": "start", "option": -1, "reaction": -1}
];

//To enable quick searching of the historybook, here is a dictionary / hash table version. Each key is the name of the encounter, a unique string, while the associated value is the turn when it occured, which also works as an index to the above array if the chosen option and reaction are also needed.

var quick_historybook = {
    //"start": 0
    //This is a hashtable which uses encounter ids as keys, and the turn the encounter occured as the value.
    //This enables us to look up an encounter in the quick historybook, then look it up in the slow historybook by using the turn that it occured as the key, making both searches O(1) in speed.
};

//The following string keeps a transcript of play. The player can normally review it at any time.

var playthrough_transcript = "";

function parseReactionsData(data){
    var reactions = [];
    var each;
    for (each of data){
        var new_reaction = new Character_Reaction(each["text_script"], each["desirability_script"], each["consequence_id"]);
        for (x of each["after_effects"]){
            new_reaction.after_effects.push(x);
        }
        reactions.push(new_reaction);
    }
    return reactions;
}

function parseOptionsData(data){
    var options = [];
    var each;
    for (each of data){
        options.push(new Player_Option(each["text_script"], each["visibility_script"], each["performability_script"], parseReactionsData(each["reactions"])));
    }
    return options;
}

//Import game data.
function importCharacterData(character_data = storyworld_data.characters){
    characters = [];
    if (0 == character_data.length){
        console.log("Warning: Storyworld includes no characters!");
    }
    var eachCh;
    for (eachCh of character_data){
        var new_character = new Character(eachCh["name"], eachCh["pronoun"], eachCh["bnumber_properties"]);
        characters.push(new_character);
    }
}

function importSpoolData(){
    spools = [];
    spool_directory = {};
    var eachSpool;
    for (eachSpool of storyworld_data.spools){
        x_spool = new Spool(eachSpool["id"], eachSpool["spool_name"], eachSpool["starts_active"]);
        for (encounter of eachSpool["encounters"]){
            //encounter is the id of the encounter, in this case, rather than the encounter itself.
            x_spool.encounters.push(encounter);
        }
        spools.push(x_spool);
        spool_directory[eachSpool["id"]] = x_spool;
    }
}

function importGameData(){
    document.getElementById("about_button").innerHTML = "About " + storyworld_data.storyworld_title;
    importCharacterData();
    importSpoolData();
    var eachEn;
    for (eachEn of storyworld_data.encounters){
        //id, title, text_script, earliest_turn, latest_turn, antagonist, options
        x_event = new Encounter(eachEn["id"], eachEn["title"], eachEn["text_script"], eachEn["acceptability_script"], eachEn["desirability_script"]);
        x_event.options = parseOptionsData(eachEn["options"]);
        encounters[eachEn["id"]] = x_event;
    }
}

//Sorting comparison functions.
function comparePageTitleAlphabetically(a, b){
    if (a.title < b.title){
        return -1;
    } else if (a.title == b.title && a.id < b.id){
        return -1;
    }
    return 1;
}

//-----------------------------
//Section 4: Saving and Loading
//-----------------------------

var save_profile = {};

function importSaveProfile(){
    if (typeof(Storage) === "undefined") {
        //Browser does not support local storage.
        return;
    }
    let save_profile_string = localStorage.getItem("save_profile");
    if (null !== save_profile_string) {
        save_profile = JSON.parse(save_profile_string);
    }
}

importSaveProfile();

//var maximum_save_count = 7; //Maximum number of saved games, excluding autosave.

function saveGame(save_filename){
    if (typeof(Storage) === "undefined") {
        //Browser does not support local storage.
        return;
    }
    save_filename = encodeURIComponent(save_filename);
    var save_dictionary = {};
    save_dictionary.save_filename = save_filename;
    save_dictionary.date = new Date().toUTCString();
    save_dictionary.historybook = slow_historybook;
    save_dictionary.characters = [];
	for (character of characters){
		save_dictionary.characters.push(character.saveData());
	}
    save_dictionary.spool_directory = {};
    for (spool of spools){
        save_dictionary.spool_directory[spool.id] = spool.currently_active;
    }
    var save_file = JSON.stringify(save_dictionary);
    localStorage.setItem("saved_game_" + save_filename, save_file);
    save_profile[save_filename] = save_dictionary.date;
    localStorage.setItem("save_profile", JSON.stringify(save_profile));
    displaySaveProfile();
    console.log("Saved game: " + save_filename);
}

function loadGame(save_filename){
    if (typeof(Storage) === "undefined") {
        //Browser does not support local storage.
        return;
    }
    //Set slow historybook to saved historybook.
    let saved_game_string = localStorage.getItem("saved_game_" + save_filename);
    if (null === saved_game_string) {
        //Saved game not found.
        onPopupConfirmation = hidePopupDialog;
        showPopupDialog('Error: Failed to load saved game: "' + save_filename + '"');
        return;
    }
    var save_dictionary = JSON.parse(saved_game_string);
    slow_historybook = save_dictionary.historybook;
	importCharacterData(save_dictionary.characters);
    for (spool of spools){
        spool.currently_active = save_dictionary.spool_directory[spool.id];
    }
    //Fill quick historybook from slow historybook.
    //Fill transcript from slow historybook as well.
    quick_historybook = {};
    playthrough_transcript = "";
    for (const [index,value] of slow_historybook.entries()){
		if (null !== value){
			quick_historybook[value.encounter] = index;
			if (-1 != value.option && -1 != value.reaction){
				writeEncounterToTranscript(value.encounter, value.option, value.reaction);
			}
		}
    }
    document.getElementById("transcript").innerHTML = playthrough_transcript;
    refreshTranscript();
    turn = slow_historybook.length;
    //Load last encounter.
    if ('undefined' === typeof slow_historybook[slow_historybook.length - 1]){
        loadTheEnd(false);//Don't record to historybook.
    } else if ('end' == slow_historybook[slow_historybook.length - 1].encounter){
        loadTheEnd(false);//Don't record to historybook.
    } else {
        loadEncounter(slow_historybook[slow_historybook.length - 1].encounter, false);//Don't record to historybook.
    }
    console.log("Loaded saved game: " + save_filename);
}

function deleteSavedGame(save_filename){
    if (typeof(Storage) === "undefined") {
        //Browser does not support local storage.
        return;
    }
    localStorage.removeItem("saved_game_" + save_filename);
    delete save_profile[save_filename];
    localStorage.setItem("save_profile", JSON.stringify(save_profile));
    displaySaveProfile();
    console.log("Deleted saved game: " + save_filename);
}

function confirmSaveGame(){
    if (typeof(Storage) === "undefined") {
        //Browser does not support local storage.
        return;
    }
    let save_name_form = document.getElementById('save_name');
    if (null === save_name_form){
        //Show error message.
		onPopupConfirmation = hidePopupDialog;
		showPopupDialog('Error: Could not read name of save game.');
        return;
    }
    let save_filename = save_name_form.value;
    if (null === localStorage.getItem("saved_game_" + save_filename)){
        //No save file by this name exists.
        saveGame(save_filename);
    } else {
		popupArgument = save_filename;
		onPopupConfirmation = onSaveOverwriteConfirmed;
		showPopupDialog('Do you wish to overwrite this savefile? "' + save_filename + '"');
    }
}

function onSaveOverwriteConfirmed(){
	saveGame(popupArgument);
}

function confirmLoadGame(save_filename){
	popupArgument = save_filename;
	onPopupConfirmation = onLoadConfirmed;
	showPopupDialog('Do you wish to load this saved game? "' + save_filename + '" Unsaved progress will be lost.');
}

function onLoadConfirmed(){
    console.log("Loading game: " + popupArgument);
	loadGame(popupArgument);
}

function confirmDeleteSavedGame(save_filename){
	popupArgument = save_filename;
	onPopupConfirmation = onDeleteConfirmed;
	showPopupDialog('Do you wish to delete this saved game? "' + save_filename + '" The savefile will be permanently erased.');
}

function onDeleteConfirmed(){
	deleteSavedGame(popupArgument);
}

function displaySaveProfile(){
    if (0 == Object.keys(save_profile).length){
        //No saved games were found.
        document.getElementById("saved_game_list").innerHTML = "";
    } else {
        var text = '<div class="menu row"><b>Saved Games:</b></div>';
        for (each in save_profile){
            text = text + '<div class="menu row">' + '<button onclick="confirmLoadGame(\'' + each + '\')">Load</button> / <button onclick="confirmDeleteSavedGame(\'' + each + '\')">Delete</button> ' + decodeURIComponent(each) + " : " + save_profile[each] + "</div>";
        }
        document.getElementById("saved_game_list").innerHTML = text;
    }
    refreshMenu();
}

function openSaveNameDialog(){
    if (typeof(Storage) === "undefined") {
        //Browser does not support local storage.
        onPopupConfirmation = hidePopupDialog;
        showPopupDialog("Your browser does not appear to support localStorage. Saving your game has, therefore, been disabled.");
    } else {
        onPopupConfirmation = confirmSaveGame;
        showPopupDialog('Enter a name for your saved game. <input type="text" id="save_name"></input>');
    }
}

//--------------------
//Section 5: Debugging
//--------------------

//-------------------------------------
//Section 6: Script Functionality
//-------------------------------------

function eventHasOccurred(encounter, option, reaction){
    //Checks whether an encounter has occurred.
    //Optionally checks whether the player chose a given option,
    //and / or whether the antagonist chose a given reaction.
    //-1 for wildcarding option and reaction.
    if (quick_historybook.hasOwnProperty(encounter)){
        if (-1 == option && -1 == reaction){
            return true;
        } else if (-1 == option){
            if (slow_historybook[quick_historybook[encounter]].reaction == reaction){
                return true;
            }
        } else if (-1 == reaction){
            if (slow_historybook[quick_historybook[encounter]].option == option){
                return true;
            }
        } else {
            if (slow_historybook[quick_historybook[encounter]].option == option && slow_historybook[quick_historybook[encounter]].reaction == reaction){
                return true;
            }
        }
    }
    return false;
}

function clampBNumber(num){
    return Math.min(Math.max(num, -0.99), 0.99);
}

function blend(x, y, w){
    const weight = ((w + 1) / 2);
    const result = x * (1 - weight) + y * weight;
    console.log("Blend of " + x.toString() + " and " + y.toString() + " with weight " + w.toString() + " equals " + result);
    return result;
}

function nudge(x, delta){
    const result = x * (1 - Math.abs(delta)) + delta;
    console.log("Nudge " + x.toString() + " by " + delta.toString() + " equals " + result);
    return clampBNumber(result);
}

function evaluateSWScript(script){
    if ("boolean" == typeof script){
        return script;
    } else if (null !== script && "object" == typeof script && Object.hasOwn(script, "script_element_type")){
        console.log("Evaluating script: " + JSON.stringify(script));
        //Track whether or not script result is poisoned.
        let poison = false;
        if ("Pointer" == script["script_element_type"] && Object.hasOwn(script, "pointer_type")){
            if ("Bounded Number Constant" == script["pointer_type"] && Object.hasOwn(script, "value")){
                return script["value"];
            } else if ("Bounded Number Pointer" == script["pointer_type"] && Object.hasOwn(script, "character") && Object.hasOwn(script, "coefficient") && Object.hasOwn(script, "keyring")){
                let character = characters[script["character"]];
                let result = script["coefficient"] * character.get_bnumber_property(script["keyring"]);
                console.log("Script is a bounded number pointer, with a value of " + result.toString() + ".");
                return result;
            } else if ("Event Pointer" == script["pointer_type"] && Object.hasOwn(script, "negated") && Object.hasOwn(script, "spool") && Object.hasOwn(script, "encounter") && Object.hasOwn(script, "option") && Object.hasOwn(script, "reaction")){
                let has_occurred = eventHasOccurred(script["encounter"], script["option"], script["reaction"]);
                if (false == script["negated"] && !(has_occurred)){
                    return false;
                } else if (true == script["negated"] && has_occurred){
                    return false;
                } else {
                    return true;
                }
            } else if ("Spool Status Pointer" == script["pointer_type"] && Object.hasOwn(script, "negated") && Object.hasOwn(script, "spool")){
                return (!script["negated"] == spool_directory[script["spool"]].currently_active);
            } else if ("String Constant" == script["pointer_type"] && Object.hasOwn(script, "value")){
                return script["value"];
            }
        } else if ("Operator" == script["script_element_type"] && Object.hasOwn(script, "operator_type") && Object.hasOwn(script, "operands") && Object.hasOwn(script, "input_type")){
            //Evaluate operands first.
            let evaluated_operands = [];
            let operands_length = script["operands"].length;
            for (let index = 0; index < operands_length; index++) {
                let parsed_operand = evaluateSWScript(script["operands"][index]);
                //Check whether or not the operand is valid before adding it to the list of evaluated operands.
                if (null !== parsed_operand && script["input_type"] == typeof parsed_operand){
                    evaluated_operands.push(parsed_operand);
                } else {
                    poison = true;
                }
            }
            operands_length = evaluated_operands.length;
            //Now evaluate operator.
            if ("Absolute Value" == script["operator_type"] && 1 == operands_length){
                return Math.abs(evaluated_operands[0]);
            } else if ("Arithmetic Mean" == script["operator_type"]){
                let sum = 0;
                let count = 0;
                for (let index = 0; index < operands_length; index++) {
                    evaluated_operand = evaluated_operands[index];
                    if ("number" == typeof evaluated_operand){
                        sum += evaluated_operands[index];
                        count += 1;
                    }
                }
                if (0 == count){
                    return 0;
                } else {
                    return sum / count;
                }
            } else if ("Arithmetic Negation" == script["operator_type"] && 1 == operands_length){
                let result = -1 * evaluated_operands[0];
                return result;
            } else if ("Blend" == script["operator_type"] && 3 == operands_length){
                let result = blend(evaluated_operands[0], evaluated_operands[1], evaluated_operands[2]);
                return result;
            } else if ("Arithmetic Comparator" == script["operator_type"] && Object.hasOwn(script, "operator_subtype") && 2 <= operands_length){
                if ("GT" == script["operator_subtype"]){
                    return (evaluated_operands[0] > evaluated_operands[1]);
                } else if ("GTE" == script["operator_subtype"]){
                    return (evaluated_operands[0] >= evaluated_operands[1]);
                } else if ("LT" == script["operator_subtype"]){
                    return (evaluated_operands[0] < evaluated_operands[1]);
                } else if ("LTE" == script["operator_subtype"]){
                    return (evaluated_operands[0] <= evaluated_operands[1]);
                }
            } else if ("Equals" == script["operator_type"] && 2 <= operands_length){
                let target_value = evaluated_operands[0];
                for (let index = 1; index < operands_length; index++) {
                    evaluated_operand = evaluated_operands[index];
                    if (target_value != evaluated_operand){
                        return false;
                    }
                }
                return true;
            } else if ("Boolean Comparator" == script["operator_type"] && Object.hasOwn(script, "operator_subtype") && 2 <= operands_length){
                if ("AND" == script["operator_subtype"]){
                    let result = true;
                    for (let index = 0; index < operands_length; index++) {
                        evaluated_operand = evaluated_operands[index];
                        result = (result && evaluated_operand);
                    }
                    return result;
                } else if ("OR" == script["operator_subtype"]){
                    let result = false;
                    for (let index = 0; index < operands_length; index++) {
                        evaluated_operand = evaluated_operands[index];
                        result = (result || evaluated_operand);
                    }
                    return result;
                } else if ("XOR" == script["operator_subtype"] && 2 <= operands_length){
                    return (evaluated_operands[0] != evaluated_operands[1]);
                }
            } else if ("Desideratum" == script["operator_type"] && 3 == operands_length){
                return clampBNumber(0.99 - Math.abs(evaluated_operands[0] - evaluated_operands[1]));
            } else if ("Nudge" == script["operator_type"] && 2 == operands_length){
                return nudge(evaluated_operands[0], evaluated_operands[1]);
            } else if ("Maximum of" == script["operator_type"] && 1 <= operands_length){
                return Math.max(...evaluated_operands);
            } else if ("Minimum of" == script["operator_type"] && 1 <= operands_length){
                return Math.min(...evaluated_operands);
            } else if ("Not" == script["operator_type"] && 1 <= operands_length){
                return !evaluated_operands[0];
            } else if ("If Then" == script["operator_type"] && 3 <= operands_length && !poison){
                for (let index = 0; index < (operands_length-1); index += 2) {
                    if (evaluated_operands[index]){
                        return evaluated_operands[index+1];
                    }
                }
                return evaluated_operands[operands_length-1];
            }
        }
    }
    console.log("Script produces null result.");
    return null;
}

function enactEffect(effect_data){
    if (null !== effect_data && "object" == typeof effect_data && Object.hasOwn(effect_data, "effect_type")){
        if ("Bounded Number Effect" == effect_data["effect_type"]){
            let character = characters[effect_data["Set"]["character"]];
            let keyring = effect_data["Set"]["keyring"];
            let value = evaluateSWScript(effect_data["to"]);
            if (null !== value && "number" == typeof value){
                value *= effect_data["Set"]["coefficient"];
                character.set_bnumber_property(keyring, value);
            }
        } else if ("Spool Effect" == effect_data["effect_type"]){
            let value = evaluateSWScript(effect_data["to"]);
            if (null !== value && "boolean" == typeof value){
                spool_directory[effect_data["Set"]].currently_active = value;
            }
        }
    }
}

//-----------------------
//Section 7: Main Process
//-----------------------

function printPerformableOption(css_class, index, text) {
    var output = '<div class="' + css_class + '"';
    output = output + ' onclick="executeOption(' + index.toString() + ')">';
    output = output + '<span class="prefix">&gt; </span>';
    output = output + text;
    output = output + '</div>';
    return output;
}

function printDisabledOption(css_class, index, text) {
    var output = '<div class="' + css_class + '"';
    output = output + ' onclick="executeOption(' + index.toString() + ')">';
    output = output + '<span class="prefix">&gt; </span>';
    output = output + '<del>&nbsp;' + text + '&nbsp;</del>';
    output = output + '</div>';
    return output;
}

//Load an encounter:
//This one is mildly complicated. It looks up an encounter in the above database and displays it to the player.
function loadEncounter(encounter_id, record = true) {
    //This function can either take a string as input, in which case it treats the string as the encounter name and looks up the encounter in the encounters database, or it can take an encounter as input, thereby skipping the database lookup.
    var encounter = encounters[encounter_id];
    console.log("Turn: " + turn + ' Displaying encounter: "' + encounter.title);
    current_page = encounter;//Track which encounter we're in.
    next_page = "start";//Set the next encounter to be semi-random.
    var encounter_sections = [];
    //Now we change the main encounter text to what it needs to be.
    var current_main_text = "";
    var continue_button_label = "";
    if (0 == storyworld_data["display_mode"]){
        //In display mode 0, the game displays the reaction on the same screen as the current encounter, then requires the player to click an extra button to proceed to the next encounter.
        text_buffer = "";
    } else if (1 == storyworld_data["display_mode"]){
        //In display mode 1, when a player chooses an option, the game clears the screen and displays the reaction text followed by the text of the next encounter.
        current_main_text += text_buffer + "";//text_buffer should be holding the text of the reaction that needs displayed.
    }
    var continue_regex = /\[\[.*\|continue\]\]/gim;
    let encounter_text = evaluateSWScript(encounter.text_script);
    if (-1 != encounter_text.search(continue_regex)){
        //If the encounter's main text is split into sections:
        //Add the first section to the text buffer,
        encounter_sections = encounter_text.split(continue_regex);
        current_main_text += encounter_sections[0];
        text_buffer = current_main_text;
        //And compile the html code for the continue button.
        continue_button_label = '<a href="javascript:continueFromBreak(1)">';
        var button_code = encounter_text.match(continue_regex)[0];
        continue_button_label += button_code.split(/(\[\[|\|continue\]\])/gi)[2];
        continue_button_label += "</a>";
    } else {
        current_main_text += encounter_text;
    }
    document.getElementById("encounter_text").innerHTML = current_main_text + continue_button_label;
    //Now we go through the options one by one, creating links for each.
    var option;
    var compiled_options = "";
    var index = 0;
    var visible_options = [];
    var visible_option_indices = [];
    for (option of encounter.options){
        if (evaluateSWScript(option.visibility_script)){
            visible_options.push(option);
            visible_option_indices.push(index);
        }
        index++;
    }
    for (let i = 0; i < visible_options.length; i++) {
        option = visible_options[i];
        let css_class = "option";
        index = visible_option_indices[i];
        let option_text = evaluateSWScript(option.text_script);
        if (1 == visible_options.length){
            css_class = css_class + " single";
        } else if (0 == i){
            css_class = css_class + " first";
        } else if (i == visible_options.length - 1){
            css_class = css_class + " last";
        } 
        if (evaluateSWScript(option.performability_script)){
            compiled_options = compiled_options + printPerformableOption(css_class, index, option_text);
        } else {
            css_class = css_class + " disabled";
            compiled_options = compiled_options + printDisabledOption(css_class, index, option_text);
        }
    }
    document.getElementById("options_list").innerHTML = compiled_options;
    //If there are no options for this encounter, or the encounter has multiple sections separated by "continue" commands, then hide the options field.
    if (0 == visible_options.length || 1 < encounter_sections.length){
        document.getElementById("options_list").style.display = "none";
    } else {
        document.getElementById("options_list").style.display = "block";
    }
    //Render the reaction field invisible.
    document.getElementById("reaction_field").style.display = "none";
    document.getElementById("reaction_text").innerHTML = "";
    if (record){//if we're recording to the historybook and transcript:
        //Update the transcript.
        document.getElementById("transcript").innerHTML = playthrough_transcript;
        refreshTranscript();
    
        //Update the historybook.
        slow_historybook[turn] = {"encounter": current_page.id, "option": -1, "reaction": -1};
        quick_historybook[current_page.id] = turn;
        //Most encounters can only be displayed once. However, the "consequence" property of character reactions bypasses the check of whether an encounter has already been displayed. In these cases the quick_historybook will only record the latest turn the encounter was displayed. Since the quick_historybook is primarilly used to check for prerequisites and disqualifiers, and to avoid displaying encounters more than once, the information needed is whether an encounter has occured; when it occured is presently less important. If future changes to the overall design eventually require it, entries to the quick_historybook can be changed to arrays of integers, rather than integers, to record all turns an encounter is displayed.
    }
    focusStory();//Scroll to start of current reaction / encounter text.
    //If all goes well... It's the player's turn!
}

function continueFromBreak(step){
    var continue_regex = /\[\[.*\|continue\]\]/gim;
    var encounter = current_page;
    var button_code = "";
    var encounter_sections = [];
    var code_blocks = [];
    let encounter_text = evaluateSWScript(encounter.text_script);
    if (-1 != encounter_text.search(continue_regex)){
        encounter_sections = encounter_text.split(continue_regex);
        code_blocks = encounter_text.match(continue_regex);
    }
    text_buffer += encounter_sections[step];
    if (encounter_sections.length <= (step + 1)){
        //Last step.
        document.getElementById("encounter_text").innerHTML = text_buffer;
        document.getElementById("options_list").style.display = "block";
    } else {
        button_code += '<a href="javascript:continueFromBreak(';
        var x = step + 1;
        button_code += x.toString();
        button_code += ')">';
        button_code += code_blocks[step].split(/(\[\[|\|continue\]\])/gi)[2];
        button_code += "</a>";
        document.getElementById("encounter_text").innerHTML = text_buffer + button_code;
    }
}

function executeOption(which){
    var reactions = current_page.options[parseInt(which)].reactions;
    var topInclination = -1;//Reset variable to lowest possible value, -1.
    var workingChoice = -1;//Which reaction will the character choose? Reset variable.
    var index = 0;
    for (reaction of reactions){
        //This chooses how a character reacts to the player's choice.
        var latestInclination = evaluateSWScript(reaction.desirability_script);
        if (null === latestInclination || "number" != typeof latestInclination){
            continue
        }
        console.log('Reaction: "' + index.toString() + '..." Inclination: ' + latestInclination.toString());
        if (latestInclination > topInclination){
            topInclination = latestInclination;
            workingChoice = index;
        }
        index++;
    }
    if (-1 == workingChoice){
        console.log("Error, no reaction selected.");
        workingChoice = 0;
    } else {
        console.log("Reaction " + workingChoice.toString() + " selected.");
    }
    //Execute reaction:
    //If a consequence encounter is defined, ensure that occurs next:
    next_page = reactions[workingChoice].consequence;
    //Make appropriate changes to character relations:
    for (effect_data of reactions[workingChoice].after_effects){
        enactEffect(effect_data);
    }
    if (!(0 > turn)){
        //We already wrote the present encounter to the quick_historybook when we displayed the encounter. We also wrote it to the slow_historybook, but left the player and character choices "blank," (i.e. at -1.) Now we record the player and character choices in the slow_historybook.
        slow_historybook[turn] = {"encounter": current_page.id, "option": which, "reaction": workingChoice};
    }
    //Change text of options list to show only the text of the option chosen by the player.
    let option_text = evaluateSWScript(current_page.options[parseInt(which)].text_script);
    document.getElementById("options_list").innerHTML = '&gt; ' + option_text;
    if (storyworld_data["debug_mode"]){//If we are in debug mode, according to the storyworld's settings, then we shall print out the character's pValues.
        text_buffer = "";//characters[current_antagonist].printCharRelationships("<br>") + "<br>";
    } else {
        text_buffer = "";
    }
    let reaction_text = evaluateSWScript(reactions[workingChoice].text_script);
    if ("string" == typeof reaction_text && "" != reaction_text){
        text_buffer += reaction_text + "<br><br>";
    }
    if (0 == storyworld_data["display_mode"]){
        //Display text of chosen reaction.
        document.getElementById("reaction_field").style.display = "block";
        document.getElementById("reaction_text").innerHTML = text_buffer;
    } else if (1 == storyworld_data["display_mode"]){
        //In display mode 1, once the player selects an option the game clears the screen, displays the reaction text, and then displays the text of the next encounter.
        document.getElementById("reaction_text").innerHTML = "";
        selectEncounter();
    }
}

//I decided to replace my "void encounter" feature with a basic screen saying "The End." Since I set the engine up to skip to the next turn with an acceptable encounter, after all. 2021 may 12.
function loadTheEnd(record = true){
    if(record){//if we're recording to the historybook and transcript:
        //Update the transcript.
        document.getElementById("transcript").innerHTML = playthrough_transcript;
        refreshTranscript();
        slow_historybook[turn] = {"encounter": "end", "option": -1, "reaction": -1};
        quick_historybook["end"] = turn;
    }
    //Now we change the main encounter text to what it needs to be.
    let ending_text = "";
    if (0 == storyworld_data["display_mode"]){
        //In display mode 0, the game displays the reaction on the same screen as the current encounter, then requires the player to click an extra button to proceed to the next encounter.
        text_buffer = "";
    } else if (1 == storyworld_data["display_mode"]){
        //In display mode 1, when a player chooses an option, the game clears the screen and displays the reaction text followed by the text of the next encounter.
        ending_text += text_buffer + "<br>";//text_buffer should be holding the text of the reaction that needs displayed.
    }
    document.getElementById("encounter_text").innerHTML = ending_text + "<b>THE END</b>";
    document.getElementById("options_list").style.display = "none";
    document.getElementById("reaction_field").style.display = "none";
}

//Update transcript with text of the present encounter, option, and reaction.
function writeToTranscript(){
    playthrough_transcript = playthrough_transcript + "<p><b>~~~~~</b></p>" + document.getElementById("encounter_text").innerHTML + "<p>" + document.getElementById("options_list").innerHTML + "</p><p>" + document.getElementById("reaction_text").innerHTML + "</p>";
}

//Update transcript with text of a specific encounter. Used when loading a saved game.
function writeEncounterToTranscript(encounter_name, option, reaction){
    var encounter;
    encounter = encounters[encounter_name];
    if ('undefined' == typeof encounter.options[option] || 'undefined' == typeof encounter.options[option].reactions[reaction]){
        //Test for corrupted savefile, or other errors.
        playthrough_transcript = playthrough_transcript + "<p><b>~~~~~</b></p>";
        if (storyworld_data["debug_mode"]) {
            playthrough_transcript = playthrough_transcript + "<b>(" + encounter.title + ")</b><br><br>";
        }
        playthrough_transcript = playthrough_transcript + evaluateSWScript(encounter.text_script) + "<p>" + '&gt; ' + "Option and/or reaction undefined." + "</p>";
    } else {
        playthrough_transcript = playthrough_transcript + "<p><b>~~~~~</b></p>";
        if (storyworld_data["debug_mode"]) {
            playthrough_transcript = playthrough_transcript + "<b>(" + encounter.title + ")</b><br><br>";
        }
        playthrough_transcript = playthrough_transcript + evaluateSWScript(encounter.text_script) + "<p>" + '&gt; ' + evaluateSWScript(encounter.options[option].text_script) + "</p><p>" + evaluateSWScript(encounter.options[option].reactions[reaction].text_script) + "</p>";
    }
}

//Find distance from current conditions to target conditions for an encounter.

function desirability(encounter){
    let result = evaluateSWScript(encounter.desirability_script);
    if (null !== result && "number" == typeof (result)){
        return result;
    } else {
        return -1;
    }
}

//Select which encounter comes next:

function selectEncounter(){
    console.log("Selecting next encounter.");
    if (0 != turn){//Unless we're just starting a new game.
        writeToTranscript();//Record the last encounter to the transcript before moving on.
    }
    turn = turn + 1;
    if ("wild" != next_page) {
        //If the reaction of the last encounter led to a consequence, that consequence occurs next.
        loadEncounter(next_page);
    } else {
        //Otherwise:
        var each_id;
        var checked_encounters = {};//These encounters have already been checked.
		var highest_desirability = -1;
        for (spool of spools){
            if (spool.currently_active){
                console.log("Checking spool: " + spool.name + ".");
                for (each_id of spool.encounters){
                    if (!checked_encounters.hasOwnProperty(each_id)){
                        checked_encounters[each_id] = true;
                        var encounter = encounters[each_id];
                        if (!quick_historybook.hasOwnProperty(encounter.id) && evaluateSWScript(encounter.acceptability_script)){
							var encounter_desirability = desirability(encounter);
                            console.log("Encounter: " + encounter.title + " deemed acceptable. Desirability equals " + encounter_desirability + ".");
							if (encounter_desirability > highest_desirability){
								highest_desirability = encounter_desirability;
								next_page = encounter;
							}
                        }
                    }
                }
            }
        }
        //If no encounters are deemed acceptable, display a message saying "THE END" instead of an encounter.
        if ("wild" == next_page){
            loadTheEnd(true);
        } else {
            console.log("Encounter: " + next_page.title + " selected.");
			//Add the chosen encounter to the historybook, then display it.
			loadEncounter(next_page.id);
        }
    }
}

//Start a new game / playthrough.
function confirmNewGame(){
	popupArgument = "";
	onPopupConfirmation = startNewGame;
	showPopupDialog("Do you wish to start a new game? Unsaved progress will be lost.");
}

function startNewGame(){
    closeMenu();
	slow_historybook = [];
	quick_historybook = {};
	playthrough_transcript = "";
    closeTranscript();
	text_buffer = "";
	turn = 0;
	current_page = null;
	next_page = "wild";
	displaySaveProfile();
	importCharacterData();//Reset Character relations.
	for (spool of spools){
		spool.currently_active = spool.starts_active;
	}
	selectEncounter();
}
</script>
</head>
<body>
<!-- Popup dialog -->
<div id="popupBackground">
	<div id="popupDialog">
		<div id="popupText"></div>
		<button id="popup_confirm_button" onclick="confirmPopupDialog()">Confirm</button> <button id="popup_cancel_button" onclick="hidePopupDialog()">Cancel</button>
	</div>
</div>
<!-- Menu -->
<button class="collapsible" onclick="toggleMenu()">Menu</button>
<div id="main_menu" class="collapsible-content menu">
<div class="row"><button id="about_button" onclick="displayAboutText()">About</button></div>
<div class="row"><button onclick="confirmNewGame()">Start New Game</button></div>
<div class="row"><button id="save_game_button" onclick="openSaveNameDialog()">Save Game</button></div>
<div id="saved_game_list"></div>
<div class="row"><div class="dropdown" id="setTheme">
<button onclick="toggleDropdown('setTheme')" class="dropbtn">Theme</button>
<div class="dropdown-content">
<button id="lilac_button" onclick="setTheme('lilac')">Lilac</button>
<button id="nightshade_button" onclick="setTheme('nightshade')">Nightshade</button>
</div></div></div>
<div class="row"><div class="dropdown" id="setFont">
<button onclick="toggleDropdown('setFont')" class="dropbtn">Font Size</button>
<div class="dropdown-content">
<button id="set_font_14" onclick="setFontSize('14')">14</button>
<button id="set_font_16" onclick="setFontSize('16')">16</button>
<button id="set_font_18" onclick="setFontSize('18')">18</button>
<button id="set_font_20" onclick="setFontSize('20')">20</button>
</div></div></div>
</div>
<!-- Transcript -->
<button class="collapsible" onclick="toggleTranscript()">Story So Far</button>
<div id="transcript" class="collapsible-content"></div>
<!-- Story -->
<fieldset id="story">
<legend><i>~~~</i></legend>
<div id="encounter_text">Once the game begins, encounter text will be placed here by a properly functioning script.</div>
</fieldset><br>
<div id="options_list"></div>
<div id="reaction_field">
<fieldset>
<legend><i>~~~</i></legend>
<div id="reaction_text">This field will display how characters react to the player's choices.</div>
<br><a href="javascript:selectEncounter()">--></a>
</fieldset>
</div><br>

<script>
//Popup dialog functionality:
const popupBackgroundElement = document.getElementById("popupBackground");
const popupDialogElement = document.getElementById("popupDialog");
popupBackgroundElement.addEventListener("click", function(event) {
	if (!popupDialogElement.contains(event.target)) {
		hidePopupDialog();
	}
});
//Import game data and load an encounter.
importGameData();
initiateGUI();
displaySaveProfile();
selectEncounter();
</script>
</body>
</html>